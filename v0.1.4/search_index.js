var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Gaussian-states-and-operations","page":"Reference","title":"Gaussian states and operations","text":"","category":"section"},{"location":"reference/#State-definitions","page":"Reference","title":"State definitions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"With the following methods you can create some basic Gaussian states.","category":"page"},{"location":"reference/#GaussianStates.vacuumstate","page":"Reference","title":"GaussianStates.vacuumstate","text":"vacuumstate([T = Float64, ]n)\n\nReturn the vacuum Gaussian state of type T on n modes\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.thermalstate","page":"Reference","title":"GaussianStates.thermalstate","text":"thermalstate(n, β, ω::AbstractVector)\n\nReturn the thermal state on n modes with inverse temperature β and frequency ω[k] for each mode k.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.randgaussianstate","page":"Reference","title":"GaussianStates.randgaussianstate","text":"randgaussianstate([T = Float64, ]n, λ; pure=false, displace=true)\n\nGenerate a random n-mode Gaussian state with element type T, in the xpxp representation.\n\nThe state is generated from the Williamson decomposition, by drawing first the n symplectic eigenvalues d_i and then applying a random symplectic transformation. Each d_i is drawn from an exponential distribution with rate λ[i], which defaults to one (λ's elements must be convertible to T). If displace is true then a random displacement in -1 1 is applied on each mode. The returned state is generally not pure, unless pure is false which forces the generation of a pure state.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Gaussian-operations","page":"Reference","title":"Gaussian operations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following methods can be applied to a GaussianState in order to simulate quantum optical operations.","category":"page"},{"location":"reference/#GaussianStates.displace","page":"Reference","title":"GaussianStates.displace","text":"displace(g::GaussianState, α::AbstractVector)\ndisplace(g::GaussianState, α, k)\n\nVariants of displace! that return a transformed copy of g leaving g itself unmodified.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.displace!","page":"Reference","title":"GaussianStates.displace!","text":"displace!(g::GaussianState, α::AbstractVector)\n\nTransform the Gaussian state g by applying the displacement operator on all modes, with parameter α[k] on mode k.\n\n\n\n\n\ndisplace!(g::GaussianState, α, k)\n\nTransform the Gaussian state g by applying the displacement operator on the k-th mode with parameter α.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.squeeze","page":"Reference","title":"GaussianStates.squeeze","text":"squeeze(g::GaussianState, ζ::AbstractVector)\nsqueeze(g::GaussianState, ζ, k)\n\nVariants of squeeze! that return a transformed copy of g leaving g itself unmodified.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.squeeze!","page":"Reference","title":"GaussianStates.squeeze!","text":"squeeze!(g::GaussianState, ζ::AbstractVector)\n\nTransform the Gaussian state g by squeezing each mode k with parameter ζ[k], by applying the operator\n\nS(ζ) = expbigl(tfrac12 ζ adja^2 - tfrac12conjζ a^2bigr)\n\non each mode.\n\nWith this definition, the squeezed vacuum state (on a single mode) is written in the eigenbasis of the number operator, with ζ = r e^iθ, as\n\nfrac1sqrtcosh r sum_n=0^+ (e^iθ tanh r)^n fracsqrt(2n)2^n n 2n\n\n\n\n\n\nsqueeze!(g::GaussianState, ζ, k)\n\nApply a squeezing transformation on the k-th mode with parameter ζ, by applying the operator\n\nS(ζ) = expbigl(tfrac12 ζ adja^2 - tfrac12conjζ a^2bigr)\n\non the selected mode.\n\nWith this definition, the squeezed vacuum state (on a single mode) is written in the eigenbasis of the number operator, with ζ = r e^iθ, as\n\nfrac1sqrtcosh r sum_n=0^+ (e^iθ tanh r)^n fracsqrt(2n)2^n n 2n\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.squeeze2","page":"Reference","title":"GaussianStates.squeeze2","text":"squeeze2(g::GaussianState, ζ, k1, k2)\n\nVariant of squeeze2! that returns a transformed copy of g leaving g itself unmodified.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.squeeze2!","page":"Reference","title":"GaussianStates.squeeze2!","text":"squeeze2!(g::GaussianState, ζ, k1, k2)\n\nApply a two-mode squeezing transformation on modes k1 and k2 with parameter ζ, by applying the operator\n\nS_2(ζ) = expbigl(ζ (adja  adja) - conjζ (a  a)bigr)\n\non the selected modes.\n\nWith this definition, the two-mode squeezed vacuum state is written in the eigenbasis of the number operator, with ζ = r e^iθ, as\n\nfrac1cosh r sum_n=0^+ (e^iθ tanh r)^n n  n\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.beamsplitter","page":"Reference","title":"GaussianStates.beamsplitter","text":"beamsplitter(g::GaussianState, transmittivity, k1, k2)\n\nVariant of beamsplitter! that returns a transformed copy of g leaving g itself unmodified.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.beamsplitter!","page":"Reference","title":"GaussianStates.beamsplitter!","text":"beamsplitter!(g::GaussianState, η, k1, k2)\n\nTransform the Gaussian state g with a beam splitter on modes k1 and k2 with transmittivity η, represented by the operator\n\nB(θ) = expbigl(θ (a  adja - adja  a)bigr)\n\nwith η = cos θ.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.lossybeamsplitter","page":"Reference","title":"GaussianStates.lossybeamsplitter","text":"lossybeamsplitter(g::GaussianState, transmittivity, loss, k1, k2)\n\nVariant of lossybeamsplitter! that returns a transformed copy of g leaving g itself unmodified.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.lossybeamsplitter!","page":"Reference","title":"GaussianStates.lossybeamsplitter!","text":"lossybeamsplitter!(g::GaussianState, transmittivity, loss, k1, k2)\n\nTransform the Gaussian state g with lossy a beam splitter on modes k1 and k2 with given transmittivity and loss parameters.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Matrix-decompositions","page":"Reference","title":"Matrix decompositions","text":"","category":"section"},{"location":"reference/#GaussianStates.williamson","page":"Reference","title":"GaussianStates.williamson","text":"williamson(M)\n\nCompute the Williamson decomposition of M, which is assumed to be a 2n  2n real positive-definite matrix. Return D, V where V is a symplectic matrix, i.e. such that V sympmat transposeV = sympmat where\n\nsympmat = I_n   \nbeginpmatrix\n  0  1\n  -1  0\nendpmatrix\n\nand D is a diagonal matrix of positive numbers, such that V D transposeV = M.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.takagiautonne","page":"Reference","title":"GaussianStates.takagiautonne","text":"takagiautonne(A; svd_order=true)\n\nCompute the Takagi-Autonne decomposition of the complex symmetric matrix A. Return D, U such that A = U D transposeU, where D is a diagonal, positive-semidefinite matrix and U is unitary.\n\nSet svd_order to true (the default) to return the result by ordering the diagonal values of D in descending order, false for ascending order.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.euler","page":"Reference","title":"GaussianStates.euler","text":"euler(M)\n\nCompute the Euler, or Bloch-Messiah, decomposition of the symplectic matrix M. Return L, D, R such that L D R = M, where L and R are orthogonal symplectic matrices with respect to the matrix\n\nsympmat = I_n   \nbeginpmatrix\n  0  1\n  -1  0\nendpmatrix\n\nand D is a diagonal matrix which can be written as\n\nbeginpmatrix\n  d_1  0\n  0  d_1^-1\nendpmatrix\n\nbeginpmatrix\n  d_2  0\n  0  d_2^-1\nendpmatrix\n dotsb \nbeginpmatrix\n  d_n  0\n  0  d_n^-1\nendpmatrix\n\nwith d_j  1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Utilities","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/#GaussianStates.nmodes","page":"Reference","title":"GaussianStates.nmodes","text":"nmodes(g::GaussianState)\n\nReturn the number of modes g is defined on.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.randposdef","page":"Reference","title":"GaussianStates.randposdef","text":"randposdef([T = Float64, ]n)\n\nGenerate an n  n real positive-definite matrix with element type T.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.randsymplectic","page":"Reference","title":"GaussianStates.randsymplectic","text":"randsymplectic([T = Float64, ]n)\n\nGenerate a random 2n  2n real symplectic matrix of element type T such that S sympmat transposeS = sympmat, with\n\nsympmat = I_n   \nbeginpmatrix\n  0  1\n  -1  0\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.number","page":"Reference","title":"GaussianStates.number","text":"number(g::GaussianState)\n\nReturn the mean number of photons in the state g.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.purity","page":"Reference","title":"GaussianStates.purity","text":"purity(g::GaussianState)\n\nReturn the purity of the state g.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.is_valid_covariance_matrix","page":"Reference","title":"GaussianStates.is_valid_covariance_matrix","text":"is_valid_covariance_matrix(σ; atol, rtol)\n\nTest whether the matrix σ satisfies the conditions to be a covariance matrix for a Gaussian state, i.e. is a 2n  2n symmetric matrix such that σ  0 and σ + isympmat  0.\n\nKeyword arguments are forwarded to isapprox to adjust the numerical thresholds of the inexact equality comparisons; atol defaults to eps(eltype(σ)) * norm(σ) when comparing with zero.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.issymplectic","page":"Reference","title":"GaussianStates.issymplectic","text":"issymplectic(M)\n\nCheck whether M is a symplectic matrix, i.e. if M sympmat transposeM = sympmat where\n\nsympmat = I_n   \nbeginpmatrix\n  0  1\n  -1  0\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"#GaussianStates.jl","page":"Home","title":"GaussianStates.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for the GaussianStates.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package defines several Gaussian maps that can be applied to Gaussian states, as well as relevant matrix decompositions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package mostly follows the notation in [1], with first and second moments R_i and sigma_ij defined as","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign\nR_i = operatornametr(rho r_i)\nsigma_ij = operatornametr(rho r_i-R_ir_j-R_j) =\n            = operatornametr(rho r_ir_j)-2R_iR_j\nendalign","category":"page"},{"location":"","page":"Home","title":"Home","text":"where r = (x_1 p_1 x_2 p_2 dotsc x_n p_n).","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Creation of vacuum, thermal, and random Gaussian states.\nMost of the Gaussian operations listed in [2].\nWilliamson, Takagi-Autonne, and Euler/Bloch-Messiah matrix decompositions.","category":"page"},{"location":"#Bibliography","page":"Home","title":"Bibliography","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A. Serafini. Quantum Continuous Variables (CRC Press, 2023).\n\n\n\nJ. B. Brask. Gaussian states and operations – a quick reference (2022), arXiv:2102.05748 [quant-ph].\n\n\n\n","category":"page"}]
}
